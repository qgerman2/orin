#ifndef CUHASH_TYPES_HPP
#define CUHASH_TYPES_HPP

#include <cstdint>

// Forward declarations for Montgomery and DefaultArith classes
namespace cupqc_common {
    constexpr uint32_t BabyBearPrime = 2013265921;

    template<uint32_t Prime>
    class Montgomery;

    template<uint32_t Prime>
    class DefaultArith;

    using BabyBearMont    = Montgomery<BabyBearPrime>;
    using BabyBearDefault = DefaultArith<BabyBearPrime>;
} // namespace cupqc_common

namespace cupqc {
    
    template<uint32_t N>
    __host__ __device__ constexpr uint32_t log2() {
        return 1 + log2<(N>>1)>();
    }

    template<>
    __host__ __device__ constexpr uint32_t log2<1>() {
        return 0;
    }

    template<uint32_t N, uint32_t M>
    __host__ __device__ constexpr uint32_t shift() {
        if constexpr (M <= log2<N>()) {
            return N / (1 << M ) + shift<N, M - 1>();
        }
        else {
            return 0;
        }
    }

    template<uint32_t N>
    __host__ __device__ constexpr uint32_t shift<N, 0>() {
        return N;
    }

    /* This is an object for storing a proof of a leaf in a merkle tree.
       The proof is a list of leaves that can be used to verify the leaf.
       The proof is generated by the generate_proof function.
       The proof is verified by the verify_proof function.
       Log2(N) leaves are stored in the proof, this is at most 21 for the current implementation.
    */
    template<uint32_t N, class Hash, typename Precision>
    class proof {
        public:
            static constexpr uint32_t size = log2<N>();
            static constexpr uint32_t digest_size = (Hash::has_digest_size) ? Hash::digest_size : (Hash::has_security_category) ? ((Hash::SecurityCategory == 1) ? 
                                                    256 / (8 * sizeof(Precision)) : 512 / (8 * sizeof(Precision))) : 256 / (8 * sizeof(Precision));
            Precision *nodes;
            uint32_t *indices;
            __host__ __device__ proof() {}
            __host__ __device__ ~proof() {}
            __host__ __device__ void allocate_proof() {
                cudaMalloc((void**)&this->nodes, size * digest_size * sizeof(Precision));
                cudaMalloc((void**)&this->indices, size * sizeof(uint32_t));
            }
            __host__ __device__ void free_proof() {
                cudaFree(this->nodes);
                cudaFree(this->indices);
            }
    };

    /* This is an object for storing a Merkle tree with N hashes at the first level. 
       This will contain 2*N - 1 nodes in total.
       The first N nodes are the leaves, the next N-2 nodes are the internal nodes, and the last node is the root.
       The root is composite hash of all the intermediate nodes.
       The internal nodes are the hashes of the two children.
       The leaves are the hashes of the input data.
    */
    template<uint32_t N, class Hash, typename Precision>
    class tree {
        public:
            static constexpr uint32_t size = 2 * N - 1; // Could be up to 2^22 - 1 for the current implementation
            static constexpr uint32_t digest_size = (Hash::has_digest_size) ? Hash::digest_size : (Hash::has_security_category) ? ((Hash::SecurityCategory == 1) ? 
                                                    256 / (8 * sizeof(Precision)) : 512 / (8 * sizeof(Precision))) : 256 / (8 * sizeof(Precision));
            Precision* nodes; // make this a global memory array since there is one tree per block
            Precision* root;
            __host__ __device__ tree() {}
            __host__ __device__ ~tree() {}
            __host__ __device__ void allocate_tree() {
                cudaMalloc((void**)&this->nodes, size * digest_size * sizeof(Precision));
                cudaMalloc((void**)&this->root, digest_size * sizeof(Precision));
            }
            __host__ __device__ void free_tree() {
                cudaFree(this->nodes);
                cudaFree(this->root);
            }
    };
}

#endif // CUHASH_TYPES_HPP